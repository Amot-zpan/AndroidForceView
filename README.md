# AndroidForceView
Android力导向图，算法来自于D3.js的v3版本。

效果图：  
![效果图](https://github.com/Amot-zpan/AndroidForceView/blob/master/art/androidforceview.gif)

详细的力导向图（力布局）的算法，请参阅 [d3-force](https://github.com/d3/d3-force/blob/master/README.md)

D3.js 是一个 JavaScript 库，主要用在前端网页中，所以在 Android 中也可以通过嵌套网页来实现力导向图的效果，但性能如何，没做过多测试。由于
D3.js 主要负责的是坐标计算，而并不管如何去绘制，官方给的示例是通过 SVG 或 Html5 的 Canvas 来绘制的，具体信息还是看官方解释吧 [D3.js](https://github.com/d3/d3)。

### Android 原生代码实现力导向图  
#### 分析  
力导向图由节点（Node）和连线（Link）组成，每个节点在运动过程中的任意一个时间点都有一个坐标，根据具体坐标就能绘制当前状态下的图。随着节点的坐标不断地变化，不停地重绘整个图，便能看到一个动态的效果，直到每个节点的坐标不再变化，整个图将保持在最后稳定状态，不再重绘。当某个节点被拖动，稳定状态被打破，整个图重复上面过程，重新到达一个新的稳定状态。

将每个节点当作一个带负电的点电荷，那么每个节点与其他所有节点都有电荷斥力，从而能使每个节点相互排斥。对于相关的节点之间有连线，能够互相拉住。另外，整个图有一个重心，这个重心为一个固定坐标，所有的节点都会受到重力的作用，但这里并没有使用物理上的重力公式，而只是一个类似效果的几何约束，防止节点逃逸。通过合力实现力的平衡，力的平衡状态也就是整个图的稳定状态。每个节点通过受力情况，来计算当前所处位置的坐标。

#### 1. 计算坐标  
虽然每个节点的坐标都是计算得到的，但总有开始状态。开始状态下的坐标设置的是获取的随机数，这个随机数可以根据当前 View 的宽高来限定。  

*`Force` 类中的 `getRandomPosition(int max)` 方法生成初始状态下的随机坐标。*

遍历所有 FNode，给每个 FNode 设置一个随机获取的坐标。

遍历所有 FLink，计算每条 FLink 的 sourceNode 和 targetNode 的距离 d，利用 α 值和 FLink 的拉力，计算 sourceNode 和 targetNode 的距离的减少量，d 越大，此次减少的距离越大（效果类似拉长的橡皮筋，拉得越长，松手后单位时间回弹的距离越大），再根据 sourceNode 和 targetNode 的 weight （weight是节点的重量，节点的子节点越多，weight越大，越不容易被拉动）更新这两个节点的坐标。
```java
// 根据 link 两端节点的位置和 link 的拉力，以及节点的重量来更新节点的坐标
for (int i = 0; i < linkCount; i++) {
    FLink link = links.get(i);
    FNode sourceNode = link.source;
    FNode targetNode = link.target;
    float dx = targetNode.x - sourceNode.x;
    float dy = targetNode.y - sourceNode.y;
    double d = dx * dx + dy * dy;
    if (d > 0) {
        d = Math.sqrt(d);

        d = alpha * linkStrength(link) * (d - linkDistance(link)) / d;
        dx *= d;
        dy *= d;

        float k = sourceNode.weight * 1.0f / (targetNode.weight + sourceNode.weight);
        targetNode.x -= dx * k;
        targetNode.y -= dy * k;

        k = 1 - k;
        sourceNode.x += dx * k;
        sourceNode.y += dy * k;
    }
}
```
遍历所有 FNode，使每个节点向 View 中心聚拢。
```java
// 几何约束，使整个图向 View 的中心聚拢
float k = alpha * gravity;
if (k != 0) {
    int w = width / 2;
    int h = height / 2;
    for (int i = 0; i < nodeCount; i++) {
        FNode node = nodes.get(i);
        node.x += (w - node.x) * k;
        node.y += (h - node.y) * k;
    }
}
```
遍历所有 FNode，获取所有节点中 x，y 的最小值 minX，minY 和最大值 maxX，maxY，则所有的节点都在这片区域内。四叉树的每个节点 Node 表示一片区域（根节点为整个区域），该节点 Node 的 4 个子节点按下标 0，1，2，3 分别表示左上，右上，左下，右下子区域，一直划分到每个 FNode 都能对应于一个 Node，这样所有的 Fnode 相当于按坐标进行了一次排序。而这样做的目的是，每个 FNode 都是带负电荷的，如果把一片区域中所有的节点当作一个大的电荷（电荷簇），那么这个区域外某个点电荷所受的电荷斥力就可以只计算与电荷簇的力，而不需要遍历其他所有节点，从而大大降低时间复杂度。代码参阅 `Force` 类的 `getQuadTree(List<FNode> nodes)` 方法。

生成四叉树之后，开始计算四叉树的每个节点 Node 的总电量，每个节点 Node 的总电量为所有子节点的总电量和自身电量的总和，而一个电荷簇的中心位置，则是根据子电荷（或电荷簇）的中位置与总的带电量（相当于权值）计算得到的。从开始创建四叉树到此时，实际上每个 FNode 的坐标还没有变，只是对整棵树进行了相应的规划。

遍历所有 FNode，将每个 FNode 与四叉树的节点 Node 的中心坐标进行相应的比较，注意 Node 代表的是一片区域，如果这个 FNode 与这个区域的距离过远，则认为该 FNode 不受这个区域所代表的电荷簇的斥力作用，否则，进一步计算斥力，并叠加受斥力效果下的坐标变化 px，py。这里，到底多远距离应该忽略斥力效果，阀值由自己决定，因为这个阀值也在一定程度上决定了整个图的收敛速度以及坐标计算的时间复杂度。

以上操作完成，也就表示每个节点 FNode 的 px，py 已经累计当前节点与其他所有节点的斥力作用，并计算而来的坐标，将该值按一定的摩擦系数（衰减系数）计算之后的结果累计到 x，y 坐标上，便得到了当前这一次状态下的整个图中每个节点的坐标。

#### 2. 从初始状态到稳定状态的控制
经过上面的一次坐标计算（一次 tick），只是得到了相对于前一个状态更稳定的效果，但受力并没有平衡，绘制出来的效果也并不是最终的效果，根据 `tick()` 方法的结束条件，可知从初始状态到稳定状态需要大概 300 次（当 α = 0.1 时）重复计算坐标。所以整个操作由一个计时器每过指定时间（这个时间过长会让界面的效果看起来卡顿）执行一次计算坐标的操作，每次坐标计算完成 invalidate 界面重绘。但实际上 View 并不是 invalidate 之后就一定会 onDraw，在频繁的 invalidate 下，手机速度快的，或是开启硬件加速的，onDraw 操作次数会相对更多，界面效果看起来也会更加流畅。

#### 3. 界面重绘与手势操作
整个效果的绘制使用的是 Canvas 绘图，根据坐标画圆、画线、画文字以及线上的箭头。详细的绘制过程，以及手势控制参阅代码。

### 一些问题
**整个计算和绘图都在 UI 线程执行的，为什么还要用计时器触发 invalidate，而不是在 onDraw 里面计算完成后，直接绘制，绘制完成后 invalidate 进行下一次**  
如果这样操作，相当于界面需要绘制每个状态下的图，而坐标计算过程是耗时操作，界面上的图就会看起来不流畅，这是测试出来的实际效果。

**计算坐标耗时，考虑用线程去计算**  
在代码中看来，UI 线程绘制每个节点的时候，只是读取坐标的操作，实际上坐标值的修改肯定是在同一个线程中操作的，但是绘制完某个点之后，去绘制下一个点的时候，坐标已经是第2次甚至第n次计算的结果了，造成的结果就是界面上的节点看起来在跳动（不是卡顿），节点之间相对位置问题，所以会出问题。

**考虑过每次计算完所有节点之后，保存一份 snapshot，绘图时，从这里面取坐标**  
实际效果是，正常绘制时，确实是所需要的效果，很流畅，也没有节点的跳动，内存消耗稍微大一点点，但虚拟机会回收。但是，当手势操作的时候，用手拖住一个节点移动的时候，绘图的坐标点和手指的实时坐标不同，出现重影，而手指所在的节点应该在手指触摸的位置，并拿这个位置去计算整个图其他节点的受力下的位置坐标，所以这个方法也不可行。

### 现状
节点在两三百个的时候，基本不会有太大问题，但节点到 500 个会明显卡顿，而到 1000 个时，会出现 ANR，计算坐标的总时间超过 10 秒。实际应用中，也不会需要太多节点，毕竟在手机上或平板上看，节点过多也会降低用户体验。所以对于在 Android 中使用力导向图，基本上能满足需要了。如果有更好的解决方案或算法，也可以联系我哦。
另外，由于计算坐标的算法与绘图相互独立的，所以要绘制其他形状或图片都是很容易修改的。

### 联系方式
E-mail: [napz@sina.cn](mailto:napz@sina.cn)





